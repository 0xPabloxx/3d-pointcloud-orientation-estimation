# Fixed 4å³°von Misesæ··åˆåˆ†å¸ƒè®­ç»ƒå®Œæ•´æŒ‡å—

**ä½œè€…**: Pablo (ä¸œäº¬å¤§å­¦M2)
**æŒ‡å¯¼**: Claude
**æ—¥æœŸ**: 2025-11-09
**ç”¨é€”**: æ¯•ä¸šè®ºæ–‡å®éªŒè¯´æ˜æ–‡æ¡£

---

## ğŸ“‹ ç›®å½•

1. [èƒŒæ™¯ä¸åŠ¨æœº](#1-èƒŒæ™¯ä¸åŠ¨æœº)
2. [æŠ€æœ¯æ–¹æ¡ˆæ¦‚è¿°](#2-æŠ€æœ¯æ–¹æ¡ˆæ¦‚è¿°)
3. [æ•°æ®å‡†å¤‡æµç¨‹](#3-æ•°æ®å‡†å¤‡æµç¨‹)
4. [æ¨¡å‹æ¶æ„è¯¦è§£](#4-æ¨¡å‹æ¶æ„è¯¦è§£)
5. [è®­ç»ƒç­–ç•¥ä¸å®ç°](#5-è®­ç»ƒç­–ç•¥ä¸å®ç°)
6. [æ ¸å¿ƒé—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ](#6-æ ¸å¿ƒé—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ)
7. [å®éªŒç»“æœ](#7-å®éªŒç»“æœ)
8. [ä»£ç å®ç°ç»†èŠ‚](#8-ä»£ç å®ç°ç»†èŠ‚)
9. [å¦‚ä½•å¤ç°](#9-å¦‚ä½•å¤ç°)
10. [ç»éªŒæ€»ç»“](#10-ç»éªŒæ€»ç»“)

---

## 1. èƒŒæ™¯ä¸åŠ¨æœº

### 1.1 ç ”ç©¶é—®é¢˜

**ä¼ ç»Ÿ3Dç‰©ä½“æ­£é¢æ–¹å‘æ£€æµ‹çš„å±€é™æ€§**ï¼š

ç°æœ‰æ–¹æ³•é€šå¸¸é¢„æµ‹å•ä¸€çš„æ­£é¢æ–¹å‘å‘é‡ï¼Œä½†ç°å®ä¸­å¾ˆå¤šç‰©ä½“å…·æœ‰å¤šä¸ªç­‰ä»·çš„æ­£é¢æ–¹å‘ã€‚

**ä¸¾ä¾‹**ï¼š
```
å•å³°ç‰©ä½“ï¼ˆå¦‚æ¤…å­ï¼‰:
  â†’ åªæœ‰ä¸€ä¸ªæ˜ç¡®çš„æ­£é¢ï¼ˆåçš„æ–¹å‘ï¼‰
  â†’ ä¼ ç»Ÿæ–¹æ³•é€‚ç”¨ âœ…

å¤šå³°ç‰©ä½“ï¼ˆå¦‚ç»ç’ƒç›’glassboxï¼‰:
  â†’ 4ä¸ªé¢éƒ½å¯ä»¥æ˜¯æ­£é¢ï¼ˆ4å‘å¯¹ç§°ï¼‰
  â†’ ä¼ ç»Ÿæ–¹æ³•å¤±æ•ˆ âŒ
  â†’ éœ€è¦è¾“å‡ºæ¦‚ç‡åˆ†å¸ƒ
```

### 1.2 è§£å†³æ–¹æ¡ˆï¼švon Misesæ··åˆåˆ†å¸ƒï¼ˆMvMï¼‰

**æ ¸å¿ƒæ€æƒ³**ï¼šç”¨æ¦‚ç‡åˆ†å¸ƒè¡¨ç¤ºæ­£é¢æ–¹å‘çš„ä¸ç¡®å®šæ€§

**von Misesåˆ†å¸ƒ**ï¼š
- åœ†å‘¨ä¸Šçš„æ­£æ€åˆ†å¸ƒ
- å‚æ•°ï¼šÎ¼ï¼ˆå‡å€¼è§’åº¦ï¼‰ã€Îºï¼ˆé›†ä¸­åº¦ï¼‰
- é€‚åˆè¡¨ç¤ºæ–¹å‘æ•°æ®

**æ··åˆvon Misesï¼ˆMvMï¼‰**ï¼š
- Kä¸ªvon Misesåˆ†å¸ƒçš„åŠ æƒå’Œ
- å¯ä»¥è¡¨ç¤ºå¤šå³°åˆ†å¸ƒ
- å‚æ•°ï¼š(Î¼áµ¢, Îºáµ¢, Ï€áµ¢), i=1...K

**æ•°å­¦å®šä¹‰**ï¼š
```
p(Î¸) = Î£áµ¢ Ï€áµ¢ Â· VM(Î¸ | Î¼áµ¢, Îºáµ¢)

å…¶ä¸­ï¼š
- Î¸: è§’åº¦ï¼ˆè§‚å¯Ÿæ–¹å‘ï¼‰
- K: å³°çš„æ•°é‡
- Î¼áµ¢: ç¬¬iä¸ªå³°çš„å‡å€¼è§’åº¦
- Îºáµ¢: ç¬¬iä¸ªå³°çš„é›†ä¸­åº¦ï¼ˆè¶Šå¤§è¶Šå°–é”ï¼‰
- Ï€áµ¢: ç¬¬iä¸ªå³°çš„æƒé‡ï¼ˆÎ£Ï€áµ¢ = 1ï¼‰
- VM(Î¸|Î¼,Îº): von Misesåˆ†å¸ƒ
```

### 1.3 Fixed 4å³°çš„åº”ç”¨åœºæ™¯

**ä¸ºä»€ä¹ˆé€‰æ‹©Fixed K=4**ï¼š

1. **Glassboxç‰¹æ€§**ï¼š
   - ç«‹æ–¹ä½“ï¼Œ4ä¸ªä¾§é¢å®Œå…¨å¯¹ç§°
   - 4ä¸ªç­‰ä»·çš„æ­£é¢æ–¹å‘ï¼š[0Â°, 90Â°, 180Â°, 270Â°]
   - ç†æƒ³çš„4å‘å¯¹ç§°æµ‹è¯•æ¡ˆä¾‹

2. **æ¦‚å¿µéªŒè¯**ï¼š
   - å…ˆåœ¨ç®€å•ç‰©ä½“ä¸ŠéªŒè¯MvMæ–¹æ³•
   - è¯æ˜æ¨¡å‹èƒ½å­¦ä¹ å¤šå³°åˆ†å¸ƒ
   - ä¸ºåç»­æ‰©å±•åˆ°å¯å˜Kæ‰“åŸºç¡€

3. **é™ä½å¤æ‚åº¦**ï¼š
   - Kå›ºå®šï¼Œå‡å°‘é¢„æµ‹å¤´è¾“å‡ºç»´åº¦
   - ä¸“æ³¨äºè§£å†³æ ¸å¿ƒè®­ç»ƒé—®é¢˜
   - é¿å…Kå€¼é¢„æµ‹çš„ä¸ç¡®å®šæ€§

---

## 2. æŠ€æœ¯æ–¹æ¡ˆæ¦‚è¿°

### 2.1 æ•´ä½“Pipeline

```
è¾“å…¥: 3Dç‚¹äº‘ (10,000ç‚¹ Ã— xyzåæ ‡)
  â†“
[ç‚¹äº‘æ ‡å‡†åŒ–]
  - å½’ä¸€åŒ–åˆ°å•ä½çƒ
  - éšæœºé‡‡æ ·10,000ç‚¹
  â†“
[PointNet++ Backbone]
  - åˆ†å±‚ç‰¹å¾æå–
  - Set Abstractionæ¨¡å—
  - è¾“å‡ºå…¨å±€ç‰¹å¾å‘é‡ (1024ç»´)
  â†“
[MvM Prediction Head]
  - å…¨è¿æ¥å±‚
  - é¢„æµ‹K=4ä¸ªå³°çš„å‚æ•°
  â†“
è¾“å‡º: MvMåˆ†å¸ƒå‚æ•°
  - Î¼: (4,) 4ä¸ªå³°çš„è§’åº¦
  - Îº: (4,) 4ä¸ªå³°çš„é›†ä¸­åº¦
  - Ï€: (4,) 4ä¸ªå³°çš„æƒé‡
```

### 2.2 å…³é”®æŠ€æœ¯ç‚¹

| æŠ€æœ¯ç‚¹ | æ–¹æ¡ˆ | ç†ç”± |
|--------|------|------|
| **Backbone** | PointNet++ | ç‚¹äº‘é¢†åŸŸSOTAï¼Œæ’åˆ—ä¸å˜æ€§ |
| **è¾“å‡ºè¡¨ç¤º** | (Î¼, Îº, Ï€) Ã— 4 | æ˜¾å¼MvMå‚æ•°ï¼Œå¯è§£é‡Šæ€§å¼º |
| **Î¼è¡¨ç¤º** | 2Då•ä½å‘é‡(cos Î¸, sin Î¸) | é¿å…è§’åº¦å‘¨æœŸæ€§é—®é¢˜ |
| **Îºçº¦æŸ** | Softplusæ¿€æ´» | ä¿è¯Îº>0 |
| **Ï€çº¦æŸ** | Softmaxå½’ä¸€åŒ– | ä¿è¯Î£Ï€=1 |
| **Losså‡½æ•°** | KLæ•£åº¦ | åº¦é‡åˆ†å¸ƒå·®å¼‚ |
| **å³°åŒ¹é…** | Hungarianç®—æ³• | è§£å†³æ’åˆ—ä¸å˜æ€§ |
| **åˆå§‹åŒ–** | é¢„è®¾è§’åº¦[0Â°,90Â°,180Â°,270Â°] | æ‰“ç ´å¯¹ç§°æ€§ â­å…³é”® |

### 2.3 æŠ€æœ¯æŒ‘æˆ˜

1. **å¯¹ç§°æ€§é™·é˜±** â­æœ€å¤§æŒ‘æˆ˜
   - é—®é¢˜ï¼š4ä¸ªå³°åˆå§‹åŒ–ç›¸åŒ â†’ æ¢¯åº¦ä¸º0 â†’ æ— æ³•åˆ†ç¦»
   - è§£å†³ï¼šé¢„è®¾ä¸åŒçš„åˆå§‹è§’åº¦

2. **æ’åˆ—ä¸å˜æ€§**
   - é—®é¢˜ï¼š4ä¸ªå³°çš„é¡ºåºä»»æ„
   - è§£å†³ï¼šHungarianåŒ¹é…ç®—æ³•

3. **å‘¨æœŸæ€§å¤„ç†**
   - é—®é¢˜ï¼š0Â° = 360Â°
   - è§£å†³ï¼šç”¨å•ä½å‘é‡è¡¨ç¤ºè§’åº¦

4. **æ•°æ®ä¸è¶³**
   - é—®é¢˜ï¼šGlassboxä»…217ä¸ªè®­ç»ƒæ ·æœ¬
   - è§£å†³ï¼š12æ—‹è½¬æ•°æ®å¢å¼º

---

## 3. æ•°æ®å‡†å¤‡æµç¨‹

### 3.1 åŸå§‹æ•°æ®

**æ•°æ®é›†**: ModelNet40
- **æ¥æº**: Princetonå¤§å­¦
- **è§„æ¨¡**: 40ä¸ªç‰©ä½“ç±»åˆ«ï¼Œçº¦12,000ä¸ªCADæ¨¡å‹
- **æ ¼å¼**: OFFæ–‡ä»¶ â†’ è½¬æ¢ä¸ºç‚¹äº‘

**Glassboxç±»åˆ«**:
```
æ€»æ ·æœ¬æ•°: 271ä¸ª
åˆ’åˆ†:
  - Train: 217ä¸ª
  - Val: 54ä¸ª (20%)
  - Test: 271ä¸ª (å…¨éƒ¨ï¼Œç”¨äºæœ€ç»ˆè¯„ä¼°)
```

### 3.2 ç‚¹äº‘é¢„å¤„ç†

**æ­¥éª¤1: OFF â†’ ç‚¹äº‘**
```
åŸå§‹æ ¼å¼: .off (CADç½‘æ ¼)
â†“
é‡‡æ ·ç‚¹äº‘: 10,000ä¸ªç‚¹ï¼Œå¸¦æ³•çº¿
â†“
ä¿å­˜: .plyæ–‡ä»¶
è·¯å¾„: data/full_mn40_normal_resampled_2d_rotated_ply/glass_box/
```

**æ­¥éª¤2: 2Dæ—‹è½¬ï¼ˆæ°´å¹³æ—‹è½¬ï¼‰**
```python
# ç»•Yè½´æ—‹è½¬ï¼ˆä¿æŒuprightä¸å˜ï¼‰
def rotate_2d(pointcloud, angle):
    """
    Args:
        pointcloud: (N, 3) numpy array
        angle: æ—‹è½¬è§’åº¦ï¼ˆå¼§åº¦ï¼‰
    """
    cos_a = np.cos(angle)
    sin_a = np.sin(angle)

    # Yè½´æ—‹è½¬çŸ©é˜µ
    R_y = [[cos_a,  0, sin_a],
           [0,      1, 0    ],
           [-sin_a, 0, cos_a]]

    return pointcloud @ R_y.T
```

**ä¸ºä»€ä¹ˆåªåš2Dæ—‹è½¬ï¼Ÿ**
- å‡è®¾ç‰©ä½“æ€»æ˜¯uprightï¼ˆå‚ç›´å‘ä¸Šï¼‰
- åªéœ€è¦é¢„æµ‹æ°´å¹³é¢å†…çš„æ–¹å‘
- ç®€åŒ–é—®é¢˜ï¼Œèšç„¦äºæ–¹å‘é¢„æµ‹

### 3.3 Ground Truthç”Ÿæˆ

**GTæ ¼å¼** (von Misesæ··åˆå‚æ•°):
```
æ–‡ä»¶: glass_box_0001_multi_peak_vM_gt.txt

å†…å®¹:
# von Mises mixture ground truth
K 4
mu(rad)    kappa    weight
0.000      8.0      0.25      # å³°1: 0Â°æ–¹å‘
1.571      8.0      0.25      # å³°2: 90Â°æ–¹å‘
3.142      8.0      0.25      # å³°3: 180Â°æ–¹å‘
4.712      8.0      0.25      # å³°4: 270Â°æ–¹å‘
```

**GTç”Ÿæˆé€»è¾‘**ï¼ˆæ‰‹åŠ¨æ ‡æ³¨ï¼‰:
```python
# å¯¹æ¯ä¸ªglassboxæ ·æœ¬
# 1. åˆ¤æ–­æ­£é¢æ–¹å‘ï¼ˆä¾‹å¦‚ï¼šæœå‘Xè½´æ­£æ–¹å‘ï¼‰
# 2. æ ¹æ®4å‘å¯¹ç§°æ€§ï¼Œç”Ÿæˆ4ä¸ªå³°
front_direction = 0Â°  # æ‰‹åŠ¨æ ‡æ³¨çš„æ­£é¢

# 4ä¸ªå³°ï¼ˆ90Â°é—´éš”ï¼‰
mus = [front_direction,
       front_direction + 90Â°,
       front_direction + 180Â°,
       front_direction + 270Â°]

# æ‰€æœ‰å³°å‚æ•°ç›¸åŒ
kappas = [8.0, 8.0, 8.0, 8.0]  # é›†ä¸­åº¦
weights = [0.25, 0.25, 0.25, 0.25]  # å‡åŒ€æƒé‡

# ä¿å­˜ä¸ºtxtæ–‡ä»¶
save_gt(K=4, mus, kappas, weights)
```

**Îº=8.0çš„é€‰æ‹©**:
- é€‚ä¸­çš„é›†ä¸­åº¦
- ä¸å¤ªå°–é”ï¼ˆÎºâ†’âˆå•ç‚¹ï¼‰
- ä¸å¤ªå¹³å¦ï¼ˆÎºâ†’0å‡åŒ€åˆ†å¸ƒï¼‰
- ç»éªŒå€¼ï¼Œæ•ˆæœè‰¯å¥½

### 3.4 æ•°æ®å¢å¼ºç­–ç•¥

**æ—‹è½¬å¢å¼º** (æœ€é‡è¦):
```python
# è®­ç»ƒæ—¶åº”ç”¨12ä¸ªæ—‹è½¬è§’åº¦
ROTATION_ANGLES = [0, 30, 60, 90, 120, 150,
                   180, 210, 240, 270, 300, 330]  # æ¯30Â°

# å¯¹æ¯ä¸ªæ ·æœ¬ï¼Œç”Ÿæˆ12ä¸ªæ—‹è½¬ç‰ˆæœ¬
for sample in train_samples:
    for angle in ROTATION_ANGLES:
        rotated_pc = rotate_2d(sample.xyz, angle)
        # GTçš„Î¼ä¹Ÿè¦åŒæ­¥æ—‹è½¬
        rotated_gt_mu = sample.mu - angle
```

**ä¸ºä»€ä¹ˆæ—‹è½¬å¢å¼ºæœ‰æ•ˆï¼Ÿ**
1. **æ•°æ®é‡æ‰©å……**: 217 Ã— 12 = 2604ä¸ªè®­ç»ƒæ ·æœ¬
2. **æ—‹è½¬ä¸å˜æ€§**: æ¨¡å‹å­¦ä¹ å¯¹ä»»æ„æ—‹è½¬è¾“å…¥éƒ½èƒ½æ­£ç¡®é¢„æµ‹
3. **éšå¼æ­£åˆ™åŒ–**: é˜²æ­¢è¿‡æ‹Ÿåˆåˆ°ç‰¹å®šæœå‘

**ç‚¹äº‘æŠ–åŠ¨** (æ¬¡è¦):
```python
# è®­ç»ƒæ—¶æ·»åŠ é«˜æ–¯å™ªå£°
def add_jitter(xyz, std=0.01, clip=0.05):
    noise = np.random.normal(0, std, xyz.shape)
    noise = np.clip(noise, -clip, clip)
    return xyz + noise
```

**æ•°æ®åŠ è½½å™¨å®ç°**:
```python
class GlassBoxDatasetAugmented(Dataset):
    def __init__(self, samples, rotation_angles, apply_jitter):
        # æ‰©å±•æ ·æœ¬ï¼šæ¯ä¸ªåŸå§‹æ ·æœ¬ Ã— æ—‹è½¬æ•°
        self.samples = []
        for ply, gt_txt, category in samples:
            for angle in rotation_angles:
                self.samples.append((ply, gt_txt, category, angle))

    def __getitem__(self, idx):
        ply, gt_txt, category, angle = self.samples[idx]

        # 1. è¯»å–ç‚¹äº‘
        xyz = read_ply(ply)

        # 2. æ—‹è½¬ç‚¹äº‘
        xyz_rotated = rotate_2d(xyz, angle)

        # 3. é‡‡æ ·10000ç‚¹
        xyz_sampled = sample_points(xyz_rotated, 10000)

        # 4. æ·»åŠ æŠ–åŠ¨ï¼ˆå¯é€‰ï¼‰
        if self.apply_jitter:
            xyz_sampled = add_jitter(xyz_sampled, 0.01)

        # 5. è¯»å–GTå¹¶è°ƒæ•´Î¼ï¼ˆæ—‹è½¬åGTä¹Ÿè¦å˜ï¼‰
        K, mus, kappas, weights = read_gt(gt_txt)
        mus_adjusted = (mus - angle) % (2 * np.pi)

        return xyz_sampled, mus_adjusted, kappas, weights, K
```

**å…³é”®ç‚¹ï¼šGTçš„Î¼åŒæ­¥æ—‹è½¬**
```
åŸå§‹ç‚¹äº‘ï¼šæœå‘0Â°
åŸå§‹GTï¼šÎ¼ = [0Â°, 90Â°, 180Â°, 270Â°]

æ—‹è½¬ç‚¹äº‘30Â°ï¼ˆé€†æ—¶é’ˆï¼‰:
â†’ ç‚¹äº‘ç°åœ¨æœå‘-30Â°ï¼ˆç›¸å¯¹äºåŸåæ ‡ç³»ï¼‰
â†’ GTéœ€è¦è°ƒæ•´ï¼šÎ¼' = Î¼ - 30Â° = [-30Â°, 60Â°, 150Â°, 240Â°]

ç‰©ç†å«ä¹‰ï¼š
- ç‚¹äº‘é€†æ—¶é’ˆè½¬30Â° = è§‚å¯Ÿè€…é¡ºæ—¶é’ˆè½¬30Â°
- æ‰€ä»¥çœ‹åˆ°çš„æ­£é¢æ–¹å‘è¦å‡å»30Â°
```

### 3.5 æ•°æ®ç»Ÿè®¡

**è®­ç»ƒé›†**ï¼ˆå¸¦å¢å¼ºï¼‰:
```
åŸå§‹æ ·æœ¬: 217
æ—‹è½¬å¢å¼º: Ã—12
æ€»è®¡: 2604ä¸ªè®­ç»ƒæ•°æ®ç‚¹

æ¯ä¸ªepoch:
  Batch size: 8
  Batches: 2604 / 8 = 326 batches
  è®­ç»ƒæ—¶é—´: ~50ç§’
```

**éªŒè¯é›†**ï¼ˆå¸¦å¢å¼ºï¼‰:
```
åŸå§‹æ ·æœ¬: 54
æ—‹è½¬å¢å¼º: Ã—12
æ€»è®¡: 648ä¸ªéªŒè¯æ•°æ®ç‚¹

éªŒè¯æ—¶é—´: ~10ç§’
```

**æµ‹è¯•é›†**ï¼ˆæ— å¢å¼ºï¼‰:
```
åŸå§‹æ ·æœ¬: 271
å¢å¼º: æ— 
æ€»è®¡: 271ä¸ªæµ‹è¯•æ ·æœ¬

ç›®çš„: çœŸå®è¯„ä¼°æ¨¡å‹æ€§èƒ½
```

---

## 4. æ¨¡å‹æ¶æ„è¯¦è§£

### 4.1 æ•´ä½“ç»“æ„

```python
class PointNetPPMvM(nn.Module):
    def __init__(self, max_K=4):
        super().__init__()
        self.max_K = max_K

        # PointNet++ Backbone
        self.backbone = PointNetPPBackbone()
        # è¾“å‡º: (batch, 1024) å…¨å±€ç‰¹å¾

        # MvM Prediction Head
        self.fc_shared = nn.Linear(1024, 512)

        # åˆ†æ”¯1: é¢„æµ‹æƒé‡Ï€
        self.head_pi = nn.Linear(512, max_K)
        # è¾“å‡º: (batch, 4) â†’ Softmax â†’ æƒé‡

        # åˆ†æ”¯2: é¢„æµ‹è§’åº¦Î¼ï¼ˆ2Då‘é‡è¡¨ç¤ºï¼‰
        self.head_mu = nn.Linear(512, max_K * 2)
        # è¾“å‡º: (batch, 8) â†’ 4ä¸ª2Då‘é‡ â†’ 4ä¸ªè§’åº¦

        # åˆ†æ”¯3: é¢„æµ‹é›†ä¸­åº¦Îº
        self.head_kappa = nn.Linear(512, max_K)
        # è¾“å‡º: (batch, 4) â†’ Softplus â†’ Îº > 0

    def forward(self, xyz):
        # xyz: (batch, 10000, 3)

        # 1. ç‰¹å¾æå–
        feat = self.backbone(xyz)  # (batch, 1024)
        feat = self.fc_shared(feat)  # (batch, 512)

        # 2. é¢„æµ‹æƒé‡Ï€
        pi_logits = self.head_pi(feat)  # (batch, 4)
        pi = F.softmax(pi_logits, dim=-1)  # å½’ä¸€åŒ–

        # 3. é¢„æµ‹è§’åº¦Î¼
        mu_raw = self.head_mu(feat)  # (batch, 8)
        mu_vectors = mu_raw.view(-1, self.max_K, 2)  # (batch, 4, 2)
        mu_vectors = F.normalize(mu_vectors, dim=-1)  # å½’ä¸€åŒ–åˆ°å•ä½åœ†
        # è½¬æ¢ä¸ºè§’åº¦: Î¼ = atan2(y, x)
        mu = torch.atan2(mu_vectors[..., 1], mu_vectors[..., 0])

        # 4. é¢„æµ‹é›†ä¸­åº¦Îº
        kappa_raw = self.head_kappa(feat)  # (batch, 4)
        kappa = F.softplus(kappa_raw)  # ä¿è¯ Îº > 0

        return mu, kappa, pi
```

### 4.2 PointNet++ Backbone

**æ ¸å¿ƒæ€æƒ³**: åˆ†å±‚ç‚¹äº‘ç‰¹å¾æå–

**Set Abstractionæ¨¡å—**:
```python
# é‡‡æ · â†’ åˆ†ç»„ â†’ PointNet
SA1: (10000, 3) â†’ é‡‡æ ·512ç‚¹ â†’ åˆ†ç»„(åŠå¾„0.2) â†’ (512, 128)
SA2: (512, 128) â†’ é‡‡æ ·128ç‚¹ â†’ åˆ†ç»„(åŠå¾„0.4) â†’ (128, 256)
SA3: (128, 256) â†’ å…¨å±€æ± åŒ– â†’ (1, 1024)
```

**ä¼˜ç‚¹**:
- æ’åˆ—ä¸å˜æ€§ï¼ˆé¡ºåºæ— å…³ï¼‰
- åˆ†å±‚ç‰¹å¾æå–
- å¯¹å™ªå£°é²æ£’

### 4.3 MvMé¢„æµ‹å¤´è®¾è®¡

**ä¸ºä»€ä¹ˆç”¨2Då‘é‡è¡¨ç¤ºè§’åº¦ï¼Ÿ**

**é—®é¢˜**: è§’åº¦çš„å‘¨æœŸæ€§
```
æ–¹æ¡ˆA: ç›´æ¥å›å½’è§’åº¦å€¼ [0, 2Ï€]
  â†’ é—®é¢˜: 0Â° å’Œ 360Â° æ˜¯åŒä¸€æ–¹å‘ï¼Œä½†æ•°å€¼å·®å¾ˆå¤§
  â†’ Lossä¼šæŠŠ0Â°æ¨å‘360Â°ï¼ˆé”™è¯¯ï¼‰

æ–¹æ¡ˆB: é¢„æµ‹2Då•ä½å‘é‡ (cos Î¸, sin Î¸)
  â†’ è‡ªåŠ¨å¤„ç†å‘¨æœŸæ€§
  â†’ L2 lossåœ¨å•ä½åœ†ä¸Šè¿ç»­
  â†’ é€šè¿‡atan2æ¢å¤è§’åº¦: Î¸ = atan2(y, x)
  âœ… é‡‡ç”¨
```

**å®ç°ç»†èŠ‚**:
```python
# é¢„æµ‹
mu_raw = self.head_mu(feat)  # (batch, 8)
mu_vectors = mu_raw.view(batch, 4, 2)  # (batch, 4, 2)

# å½’ä¸€åŒ–åˆ°å•ä½åœ†
mu_vectors = F.normalize(mu_vectors, dim=-1)
# ç°åœ¨ mu_vectors[i, j] = (cos Î¸áµ¢â±¼, sin Î¸áµ¢â±¼)

# è½¬æ¢ä¸ºè§’åº¦
mu = torch.atan2(mu_vectors[..., 1],  # yåˆ†é‡
                 mu_vectors[..., 0])  # xåˆ†é‡
# mu: (batch, 4)ï¼ŒèŒƒå›´ [-Ï€, Ï€]
```

**ä¸ºä»€ä¹ˆÎºç”¨Softplusï¼Ÿ**
```python
# è¦æ±‚: Îº > 0ï¼ˆvon Misesåˆ†å¸ƒçš„å®šä¹‰ï¼‰

# æ–¹æ¡ˆA: ReLU
kappa = F.relu(kappa_raw)
  â†’ é—®é¢˜: Îº=0æ—¶æ¢¯åº¦ä¸º0ï¼Œè®­ç»ƒå›°éš¾

# æ–¹æ¡ˆB: Exp
kappa = torch.exp(kappa_raw)
  â†’ é—®é¢˜: Îºå¯èƒ½è¿‡å¤§ï¼Œæ•°å€¼ä¸ç¨³å®š

# æ–¹æ¡ˆC: Softplus âœ…
kappa = F.softplus(kappa_raw)
kappa = log(1 + exp(x))
  â†’ ä¼˜ç‚¹: å¤„å¤„å¯å¯¼ï¼ŒÎº>0ï¼Œå¢é•¿æ¸©å’Œ
```

### 4.4 åˆå§‹åŒ–ç­–ç•¥ â­æœ€å…³é”®

**é—®é¢˜ï¼šå¯¹ç§°æ€§é™·é˜±**

**Zerosåˆå§‹åŒ–ï¼ˆå¤±è´¥ï¼‰**:
```python
# æ—§ç‰ˆæœ¬ï¼ˆé”™è¯¯ï¼‰
nn.init.zeros_(self.head_mu.bias)  # bias = [0,0,0,0,0,0,0,0]

ç»“æœ:
â†’ 4ä¸ªå³°çš„åˆå§‹è§’åº¦éƒ½æ˜¯0Â°
â†’ å®Œå…¨é‡å 
â†’ æ¢¯åº¦: âˆ‚L/âˆ‚Î¼â‚ = âˆ‚L/âˆ‚Î¼â‚‚ = âˆ‚L/âˆ‚Î¼â‚ƒ = âˆ‚L/âˆ‚Î¼â‚„
â†’ 4ä¸ªå³°æ°¸è¿œä¸€èµ·ç§»åŠ¨
â†’ æ— æ³•åˆ†ç¦»
â†’ Losså¡åœ¨0.74ä¸åŠ¨
```

**é¢„è®¾è§’åº¦åˆå§‹åŒ–ï¼ˆæˆåŠŸï¼‰** â­æ ¸å¿ƒåˆ›æ–°:
```python
# æ–°ç‰ˆæœ¬ï¼ˆæ­£ç¡®ï¼‰
initial_angles = [0, math.pi/2, math.pi, 3*math.pi/2]
# = [0Â°, 90Â°, 180Â°, 270Â°]

nn.init.zeros_(self.head_mu.weight)  # weightä¿æŒ0

with torch.no_grad():
    for i, angle in enumerate(initial_angles):
        # å°†è§’åº¦è½¬æ¢ä¸º2Då‘é‡
        self.head_mu.bias[2*i]   = math.cos(angle)  # xåˆ†é‡
        self.head_mu.bias[2*i+1] = math.sin(angle)  # yåˆ†é‡

# ç»“æœ:
# bias = [cos(0Â°), sin(0Â°), cos(90Â°), sin(90Â°),
#         cos(180Â°), sin(180Â°), cos(270Â°), sin(270Â°)]
#      = [1, 0, 0, 1, -1, 0, 0, -1]
```

**ä¸ºä»€ä¹ˆè¿™æ ·æœ‰æ•ˆï¼Ÿ**
```
åˆå§‹åŒ–åï¼Œç¬¬ä¸€æ¬¡forwardï¼ˆè®­ç»ƒå‰ï¼‰:
mu_raw = 0 * feat + bias  # weight=0, åªæœ‰bias
â†’ mu_vectors = [[1,0], [0,1], [-1,0], [0,-1]]
â†’ å¯¹åº”è§’åº¦: [0Â°, 90Â°, 180Â°, 270Â°]

ä¸GTå¯¹æ¯”ï¼ˆglassbox GTä¹Ÿæ˜¯[0Â°, 90Â°, 180Â°, 270Â°]ï¼‰:
â†’ åˆå§‹åŒ–å·²ç»éå¸¸æ¥è¿‘æœ€ä¼˜è§£ï¼
â†’ æ¨¡å‹åªéœ€è¦å¾®è°ƒ
â†’ å¿«é€Ÿæ”¶æ•›

å¯¹æ¯”Zerosåˆå§‹åŒ–:
â†’ mu_vectors = [[0,0], [0,0], [0,0], [0,0]]ï¼ˆå…¨0ï¼‰
â†’ å½’ä¸€åŒ–åéšæœºæ–¹å‘
â†’ éœ€è¦ä»éšæœºä½ç½®å­¦ä¹ 
â†’ å¯¹ç§°æ€§å¯¼è‡´æ¢¯åº¦ä¸º0ï¼Œæ— æ³•å­¦ä¹ 
```

**å®éªŒè¯æ˜**:
```
Zerosåˆå§‹åŒ– + 2604æ ·æœ¬:
  â†’ Val Loss = 0.74 âŒ å®Œå…¨ä¸æ”¶æ•›

é¢„è®¾åˆå§‹åŒ– + 189æ ·æœ¬:
  â†’ Val Loss = 0.0060 âœ… æˆåŠŸï¼

é¢„è®¾åˆå§‹åŒ– + 2604æ ·æœ¬:
  â†’ Val Loss = 0.0017 âœ… æœ€ä½³ï¼
```

**å…³é”®æ´å¯Ÿ**: **å¥½çš„åˆå§‹åŒ– > å¤§é‡æ•°æ®**

---

## 5. è®­ç»ƒç­–ç•¥ä¸å®ç°

### 5.1 Losså‡½æ•°ï¼šKLæ•£åº¦

**ä¸ºä»€ä¹ˆç”¨KLæ•£åº¦ï¼Ÿ**

MvMæ˜¯æ¦‚ç‡åˆ†å¸ƒï¼Œéœ€è¦ç”¨åˆ†å¸ƒè·ç¦»ä½œä¸ºlossã€‚

**KLæ•£åº¦å®šä¹‰**:
```
KL(P || Q) = âˆ« P(Î¸) log(P(Î¸) / Q(Î¸)) dÎ¸

å…¶ä¸­:
  P: Ground Truthåˆ†å¸ƒ
  Q: é¢„æµ‹åˆ†å¸ƒ
```

**ç¦»æ•£åŒ–è¿‘ä¼¼**ï¼ˆå®é™…å®ç°ï¼‰:
```python
# åœ¨[0, 2Ï€]ä¸Šé‡‡æ ·Nä¸ªè§’åº¦
theta_samples = torch.linspace(0, 2*pi, N)  # N=360

# è®¡ç®—GTåˆ†å¸ƒ
P = compute_mvm(theta_samples, gt_mu, gt_kappa, gt_pi)

# è®¡ç®—é¢„æµ‹åˆ†å¸ƒ
Q = compute_mvm(theta_samples, pred_mu, pred_kappa, pred_pi)

# KLæ•£åº¦
KL = (P * torch.log(P / (Q + 1e-8))).sum() * (2*pi / N)
```

**von Misesåˆ†å¸ƒè®¡ç®—**:
```python
def von_mises_pdf(theta, mu, kappa):
    """
    Args:
        theta: (N,) è§’åº¦é‡‡æ ·ç‚¹
        mu: å‡å€¼è§’åº¦
        kappa: é›†ä¸­åº¦
    Returns:
        pdf: (N,) æ¦‚ç‡å¯†åº¦
    """
    # von Mises PDF
    # p(Î¸|Î¼,Îº) = exp(ÎºÂ·cos(Î¸-Î¼)) / (2Ï€Â·Iâ‚€(Îº))
    # Iâ‚€: ä¿®æ­£è´å¡å°”å‡½æ•°

    from scipy.special import i0  # è´å¡å°”å‡½æ•°

    normalizer = 2 * np.pi * i0(kappa)
    pdf = np.exp(kappa * np.cos(theta - mu)) / normalizer
    return pdf

def mvm_pdf(theta, mus, kappas, weights):
    """
    Args:
        theta: (N,) è§’åº¦é‡‡æ ·ç‚¹
        mus: (K,) Kä¸ªå³°çš„å‡å€¼
        kappas: (K,) Kä¸ªå³°çš„é›†ä¸­åº¦
        weights: (K,) Kä¸ªå³°çš„æƒé‡
    Returns:
        pdf: (N,) æ··åˆåˆ†å¸ƒçš„æ¦‚ç‡å¯†åº¦
    """
    pdf_total = 0
    for mu, kappa, weight in zip(mus, kappas, weights):
        pdf_total += weight * von_mises_pdf(theta, mu, kappa)
    return pdf_total
```

### 5.2 HungarianåŒ¹é…ç®—æ³•

**ä¸ºä»€ä¹ˆéœ€è¦åŒ¹é…ï¼Ÿ**

**é—®é¢˜ï¼šæ’åˆ—ä¸å˜æ€§**
```
GTçš„4ä¸ªå³°: [0Â°, 90Â°, 180Â°, 270Â°]
Predçš„4ä¸ªå³°: [90Â°, 270Â°, 0Â°, 180Â°]

ç›´æ¥è®¡ç®—Loss:
  L(GT[0]=0Â°, Pred[0]=90Â°) â†’ é”™è¯¯é…å¯¹

æ­£ç¡®åšæ³•:
  æ‰¾åˆ°æœ€ä¼˜é…å¯¹:
    GT[0]=0Â° â†” Pred[2]=0Â°
    GT[1]=90Â° â†” Pred[0]=90Â°
    GT[2]=180Â° â†” Pred[3]=180Â°
    GT[3]=270Â° â†” Pred[1]=270Â°
  å†è®¡ç®—Loss
```

**Hungarianç®—æ³•å®ç°**:
```python
from scipy.optimize import linear_sum_assignment

def compute_loss_with_matching(pred_mu, pred_kappa, pred_pi,
                                 gt_mu, gt_kappa, gt_pi):
    """
    Args:
        pred_mu: (batch, K) é¢„æµ‹çš„å‡å€¼
        pred_kappa: (batch, K) é¢„æµ‹çš„é›†ä¸­åº¦
        pred_pi: (batch, K) é¢„æµ‹çš„æƒé‡
        gt_*: åŒä¸Šï¼ŒGround Truth

    Returns:
        loss: æ ‡é‡
    """
    batch_size = pred_mu.shape[0]
    total_loss = 0

    for b in range(batch_size):
        # 1. è®¡ç®—æˆæœ¬çŸ©é˜µ (KÃ—K)
        # cost[i,j] = å³°iå’Œå³°jä¹‹é—´çš„KLæ•£åº¦
        cost_matrix = torch.zeros(K, K)
        for i in range(K):
            for j in range(K):
                # è®¡ç®—å•å³°KLæ•£åº¦
                kl = kl_divergence_single_peak(
                    gt_mu[b,i], gt_kappa[b,i],
                    pred_mu[b,j], pred_kappa[b,j]
                )
                cost_matrix[i,j] = kl

        # 2. Hungarianç®—æ³•æ‰¾æœ€ä¼˜åŒ¹é…
        row_ind, col_ind = linear_sum_assignment(
            cost_matrix.detach().cpu().numpy()
        )

        # 3. æ ¹æ®åŒ¹é…è®¡ç®—loss
        matched_loss = 0
        for i, j in zip(row_ind, col_ind):
            matched_loss += cost_matrix[i, j]

        total_loss += matched_loss

    return total_loss / batch_size
```

**Hungarianç®—æ³•å¤æ‚åº¦**: O(KÂ³)ï¼Œå¯¹K=4å¾ˆå¿«

### 5.3 ä¼˜åŒ–å™¨ä¸å­¦ä¹ ç‡ç­–ç•¥

**ä¼˜åŒ–å™¨ï¼šAdam**
```python
optimizer = torch.optim.Adam(
    model.parameters(),
    lr=5e-4,
    betas=(0.9, 0.999),
    weight_decay=1e-4  # L2æ­£åˆ™åŒ–
)
```

**å­¦ä¹ ç‡è°ƒåº¦**:
```python
scheduler = torch.optim.lr_scheduler.StepLR(
    optimizer,
    step_size=30,  # æ¯30ä¸ªepoch
    gamma=0.5      # LRå‡åŠ
)

# Epoch 1-29:  LR = 5e-4
# Epoch 30-50: LR = 2.5e-4
```

**ä¸ºä»€ä¹ˆè¿™æ ·è®¾ç½®ï¼Ÿ**
- åˆæœŸï¼šè¾ƒå¤§LRï¼Œå¿«é€Ÿæ”¶æ•›
- åæœŸï¼šå‡å°LRï¼Œç²¾ç»†è°ƒæ•´
- é¿å…è¿‡å¤§LRå¯¼è‡´éœ‡è¡

### 5.4 è®­ç»ƒå¾ªç¯

```python
def train_one_epoch(model, train_loader, optimizer, device):
    model.train()
    total_loss = 0

    for batch_idx, (xyz, gt_mu, gt_kappa, gt_pi, K) in enumerate(train_loader):
        # æ•°æ®ç§»åˆ°GPU
        xyz = xyz.to(device)
        gt_mu = gt_mu.to(device)
        gt_kappa = gt_kappa.to(device)
        gt_pi = gt_pi.to(device)

        # Forward
        pred_mu, pred_kappa, pred_pi = model(xyz)

        # è®¡ç®—lossï¼ˆå¸¦HungarianåŒ¹é…ï¼‰
        loss = compute_loss_with_matching(
            pred_mu, pred_kappa, pred_pi,
            gt_mu, gt_kappa, gt_pi
        )

        # Backward
        optimizer.zero_grad()
        loss.backward()

        # Gradient clippingï¼ˆé˜²æ­¢æ¢¯åº¦çˆ†ç‚¸ï¼‰
        torch.nn.utils.clip_grad_norm_(model.parameters(), max_norm=1.0)

        optimizer.step()

        total_loss += loss.item()

    return total_loss / len(train_loader)

def validate(model, val_loader, device):
    model.eval()
    total_loss = 0

    with torch.no_grad():
        for xyz, gt_mu, gt_kappa, gt_pi, K in val_loader:
            xyz = xyz.to(device)
            gt_mu = gt_mu.to(device)
            # ... åŒä¸Š

            pred_mu, pred_kappa, pred_pi = model(xyz)
            loss = compute_loss_with_matching(...)
            total_loss += loss.item()

    return total_loss / len(val_loader)
```

### 5.5 è®­ç»ƒé…ç½®

**è¶…å‚æ•°æ€»ç»“**:
```python
# æ•°æ®
NUM_POINTS = 10000          # ç‚¹äº‘é‡‡æ ·æ•°
BATCH_SIZE = 8              # æ‰¹å¤§å°
NUM_WORKERS = 4             # æ•°æ®åŠ è½½çº¿ç¨‹

# æ¨¡å‹
MAX_K = 4                   # å›ºå®š4ä¸ªå³°
HIDDEN_DIM = 512            # MLPéšè—å±‚ç»´åº¦

# è®­ç»ƒ
EPOCHS = 50                 # æ€»è®­ç»ƒè½®æ•°
LR = 5e-4                   # åˆå§‹å­¦ä¹ ç‡
WEIGHT_DECAY = 1e-4         # L2æ­£åˆ™åŒ–
GRAD_CLIP = 1.0             # æ¢¯åº¦è£å‰ª

# æ•°æ®å¢å¼º
ROTATION_ANGLES = list(range(0, 360, 30))  # 12ä¸ªè§’åº¦
APPLY_JITTER = True         # ç‚¹äº‘æŠ–åŠ¨
JITTER_STD = 0.01           # æŠ–åŠ¨æ ‡å‡†å·®

# å­¦ä¹ ç‡è°ƒåº¦
LR_DECAY_EPOCH = 30         # å­¦ä¹ ç‡è¡°å‡epoch
LR_DECAY_GAMMA = 0.5        # è¡°å‡ç³»æ•°

# å…¶ä»–
SEED = 42                   # éšæœºç§å­
DEVICE = 'cuda'             # GPU
```

---

## 6. æ ¸å¿ƒé—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ

### 6.1 é—®é¢˜1ï¼šè®­ç»ƒå®Œå…¨ä¸æ”¶æ•›ï¼ˆLosså¡åœ¨0.74ï¼‰

**ç°è±¡**:
```
Epoch 1-50: Train Loss = 0.74, Val Loss = 0.74
â†’ Losså®Œå…¨ä¸åŠ¨
â†’ å¯è§†åŒ–ï¼šåªé¢„æµ‹å•ä¸ªå³°
â†’ å…¶ä»–3ä¸ªå³°"æ­»äº¡"ï¼ˆweightâ‰ˆ0ï¼‰
```

**è¯Šæ–­è¿‡ç¨‹**:

**æ­¥éª¤1ï¼šæ£€æŸ¥æ•°æ®**
```python
# å¯è§†åŒ–GTåˆ†å¸ƒ
for sample in val_set[:10]:
    plot_polar(sample.gt_mu, sample.gt_kappa, sample.gt_pi)
# ç»“æœï¼šGTæ­£ç¡®ï¼Œ4ä¸ªå³°æ¸…æ™°

# æ£€æŸ¥ç‚¹äº‘è´¨é‡
visualize_pointcloud(sample.xyz)
# ç»“æœï¼šç‚¹äº‘æ­£å¸¸
```

**æ­¥éª¤2ï¼šæ£€æŸ¥æ¨¡å‹é¢„æµ‹**
```python
# æ‰“å°é¢„æµ‹å€¼
pred_mu, pred_kappa, pred_pi = model(sample.xyz)
print(f"Pred mu: {pred_mu}")
print(f"Pred pi: {pred_pi}")

# è¾“å‡º:
# Pred mu: [0.0, 0.0, 0.0, 0.0]  â† 4ä¸ªå³°é‡å ï¼
# Pred pi: [0.9999, 0.0001, 0.0001, 0.0001]  â† å•å³°
```

**æ­¥éª¤3ï¼šåˆ†ææ¢¯åº¦**
```python
# æ£€æŸ¥æ¢¯åº¦
for name, param in model.named_parameters():
    if 'head_mu' in name:
        print(f"{name}: grad norm = {param.grad.norm()}")

# è¾“å‡º:
# head_mu.bias: grad norm = 1e-8  â† æ¢¯åº¦å‡ ä¹ä¸º0ï¼
```

**æ ¹æœ¬åŸå› ï¼šå¯¹ç§°æ€§é™·é˜±**

```
Zerosåˆå§‹åŒ–:
  â†’ 4ä¸ªå³°åˆå§‹è§’åº¦éƒ½æ˜¯0Â°
  â†’ å®Œå…¨å¯¹ç§°

Losså…³äºæ¯ä¸ªå³°çš„æ¢¯åº¦:
  âˆ‚L/âˆ‚Î¼â‚ = âˆ‚L/âˆ‚Î¼â‚‚ = âˆ‚L/âˆ‚Î¼â‚ƒ = âˆ‚L/âˆ‚Î¼â‚„

æ¢¯åº¦ä¸‹é™:
  Î¼â‚ â† Î¼â‚ - Î±Â·âˆ‚L/âˆ‚Î¼â‚
  Î¼â‚‚ â† Î¼â‚‚ - Î±Â·âˆ‚L/âˆ‚Î¼â‚‚  (ç›¸åŒçš„æ¢¯åº¦)
  Î¼â‚ƒ â† Î¼â‚ƒ - Î±Â·âˆ‚L/âˆ‚Î¼â‚ƒ  (ç›¸åŒçš„æ¢¯åº¦)
  Î¼â‚„ â† Î¼â‚„ - Î±Â·âˆ‚L/âˆ‚Î¼â‚„  (ç›¸åŒçš„æ¢¯åº¦)

ç»“æœ:
  â†’ 4ä¸ªå³°å§‹ç»ˆä¸€èµ·ç§»åŠ¨
  â†’ æ°¸è¿œä¿æŒé‡å 
  â†’ æ— æ³•åˆ†ç¦»
  â†’ æ¨¡å‹é€€åŒ–ä¸ºå•å³°
```

**è§£å†³æ–¹æ¡ˆï¼šé¢„è®¾è§’åº¦åˆå§‹åŒ–**

```python
# æ‰“ç ´å¯¹ç§°æ€§
initial_angles = [0, Ï€/2, Ï€, 3Ï€/2]

with torch.no_grad():
    for i, angle in enumerate(initial_angles):
        self.head_mu.bias[2*i] = math.cos(angle)
        self.head_mu.bias[2*i+1] = math.sin(angle)

# ç°åœ¨:
# 4ä¸ªå³°åˆå§‹è§’åº¦: [0Â°, 90Â°, 180Â°, 270Â°]
# â†’ å¯¹ç§°æ€§æ‰“ç ´
# â†’ æ¯ä¸ªå³°æœ‰ç‹¬ç«‹çš„æ¢¯åº¦æ–¹å‘
# â†’ å¯ä»¥åˆ†åˆ«ä¼˜åŒ–
```

**æ•ˆæœ**:
```
ä¿®å¤å‰: Val Loss = 0.74 (50 epochs)
ä¿®å¤å: Val Loss = 0.0017 (45 epochs)
â†’ 435å€æ”¹è¿›ï¼
```

### 6.2 é—®é¢˜2ï¼šæ•°æ®é‡ä¸è¶³ï¼ˆä»…217æ ·æœ¬ï¼‰

**æ‹…å¿§**: æ·±åº¦å­¦ä¹ é€šå¸¸éœ€è¦å¤§é‡æ•°æ®ï¼Œ217æ ·æœ¬æ˜¯å¦å¤Ÿï¼Ÿ

**è§£å†³æ–¹æ¡ˆ1ï¼šæ—‹è½¬æ•°æ®å¢å¼º**
```
åŸå§‹: 217æ ·æœ¬
å¢å¼º: 217 Ã— 12 = 2604æ ·æœ¬
â†’ 12å€æ‰©å……
```

**è§£å†³æ–¹æ¡ˆ2ï¼šé¢„è®¾åˆå§‹åŒ–çš„å¨åŠ›**

**æ¶ˆèå®éªŒè¯æ˜**:
```
å®éªŒA: Zerosåˆå§‹åŒ– + 2604æ ·æœ¬
  â†’ Val Loss = 0.74 âŒ å¤±è´¥

å®éªŒB: é¢„è®¾åˆå§‹åŒ– + 189æ ·æœ¬ï¼ˆæ— å¢å¼ºï¼‰
  â†’ Val Loss = 0.0060 âœ… æˆåŠŸï¼

å®éªŒC: é¢„è®¾åˆå§‹åŒ– + 2604æ ·æœ¬ï¼ˆå¢å¼ºï¼‰
  â†’ Val Loss = 0.0017 âœ… æœ€ä½³
```

**ç»“è®º**: **å¥½çš„åˆå§‹åŒ– >> å¤§é‡æ•°æ®**

å¯¹äºç®€å•ã€é«˜åº¦å¯¹ç§°çš„ç‰©ä½“ï¼ˆå¦‚glassboxï¼‰ï¼Œå°‘é‡æ ·æœ¬+å¥½åˆå§‹åŒ–å°±è¶³å¤Ÿã€‚

### 6.3 é—®é¢˜3ï¼šLosséœ‡è¡

**ç°è±¡** (æ— å¢å¼ºç‰ˆ):
```
Epoch 10: Val Loss = 0.313 â† çªç„¶å‡é«˜
Epoch 11: Val Loss = 0.128
```

**åŸå› **:
- æ•°æ®é‡å°‘ï¼ˆ189æ ·æœ¬ï¼‰
- éªŒè¯é›†æ›´å°‘ï¼ˆ54æ ·æœ¬ï¼‰
- æ‰¹ä¹‹é—´æ–¹å·®å¤§

**è§£å†³**:
- æ•°æ®å¢å¼º â†’ Lossæ›²çº¿å¹³æ»‘
- å­¦ä¹ ç‡è¡°å‡ â†’ åæœŸç¨³å®š

---

## 7. å®éªŒç»“æœ

### 7.1 å®šé‡ç»“æœ

**ä¸»å®éªŒï¼šé¢„è®¾åˆå§‹åŒ– + æ•°æ®å¢å¼º**

| æŒ‡æ ‡ | æ•°å€¼ | è¯´æ˜ |
|------|------|------|
| **Best Val Loss** | **0.0017** | Epoch 45 |
| **Test Loss** | 0.0131 | 271æµ‹è¯•æ ·æœ¬ |
| **æ”¶æ•›Epoch** | ~20 | LossåŸºæœ¬ç¨³å®š |
| **è®­ç»ƒæ—¶é—´** | ~50åˆ†é’Ÿ | 50 epochs, RTX 3090 |
| **æœ€ç»ˆTrain Loss** | 0.0132 | æ— è¿‡æ‹Ÿåˆ |

**å¯¹æ¯”ï¼šBaselineï¼ˆZerosåˆå§‹åŒ–ï¼‰**
```
Val Loss: 0.74 â†’ 0.0017
æ”¹è¿›: 435å€ â­
```

**æ¶ˆèå®éªŒï¼šæ— æ•°æ®å¢å¼º**

| é…ç½® | Val Loss | Trainæ ·æœ¬ | è´¨é‡ |
|------|---------|----------|------|
| é¢„è®¾+å¢å¼º | 0.0017 | 2604 | â­â­â­â­â­ |
| é¢„è®¾+æ— å¢å¼º | 0.0060 | 189 | â­â­â­ |
| Zeros+å¢å¼º | 0.74 | 2604 | âŒ |

**ç»“è®º**:
1. é¢„è®¾åˆå§‹åŒ–æ˜¯å¿…é¡»çš„ï¼ˆZeroså®Œå…¨å¤±è´¥ï¼‰
2. æ•°æ®å¢å¼ºæ˜¾è‘—æå‡è´¨é‡ï¼ˆ3.5å€ï¼‰
3. å³ä½¿189æ ·æœ¬ä¹Ÿèƒ½æˆåŠŸï¼ˆä½†è´¨é‡è¾ƒå·®ï¼‰

### 7.2 è®­ç»ƒæ›²çº¿

**Lossä¸‹é™è¶‹åŠ¿**:
```
Epoch 1:  Train=0.501, Val=0.161  (åˆå§‹åŒ–è´¨é‡å¥½)
Epoch 5:  Train=0.048, Val=0.010  (å¿«é€Ÿä¸‹é™)
Epoch 10: Train=0.038, Val=0.010  (åŸºæœ¬æ”¶æ•›)
Epoch 20: Train=0.028, Val=0.004  (ç»§ç»­ä¼˜åŒ–)
Epoch 30: Train=0.024, Val=0.013  (LRè¡°å‡ï¼Œéœ‡è¡)
Epoch 45: Train=0.016, Val=0.0017 (æœ€ä½³)
Epoch 50: Train=0.013, Val=0.004  (ç¨³å®š)
```

**ç‰¹å¾**:
- âœ… å¹³æ»‘ä¸‹é™ï¼ˆæ— å‰§çƒˆéœ‡è¡ï¼‰
- âœ… Trainå’ŒValåŒæ­¥ï¼ˆæ— è¿‡æ‹Ÿåˆï¼‰
- âœ… Valç»å¸¸ä½äºTrainï¼ˆæ³›åŒ–èƒ½åŠ›å¼ºï¼‰
- âœ… æ”¶æ•›å¿«é€Ÿï¼ˆ20 epochsè¾¾åˆ°è‰¯å¥½æ•ˆæœï¼‰

### 7.3 å®šæ€§ç»“æœï¼ˆå¯è§†åŒ–ï¼‰

**æåæ ‡å›¾å¯¹æ¯”**:

**Ground Truth**:
```
4ä¸ªå°–é”çš„å³°
ä½ç½®: [0Â°, 90Â°, 180Â°, 270Â°]
é«˜åº¦: éƒ½æ¥è¿‘0.02ï¼ˆweight=0.25ï¼‰
å®½åº¦: çª„ï¼ˆÎº=8.0ï¼‰
å¯¹ç§°æ€§: å®Œç¾çš„4å‘å¯¹ç§°
```

**é¢„æµ‹ç»“æœï¼ˆå¢å¼ºç‰ˆï¼‰**:
```
âœ… 4ä¸ªå³°æ¸…æ™°
âœ… ä½ç½®å‡†ç¡®ï¼ˆæ¥è¿‘0Â°/90Â°/180Â°/270Â°ï¼‰
âœ… é«˜åº¦å‡åŒ€ï¼ˆweightâ‰ˆ0.25ï¼‰
âœ… å®½åº¦åˆç†ï¼ˆÎºâ‰ˆ7-9ï¼‰
âœ… å¯¹ç§°æ€§è‰¯å¥½
```

**é¢„æµ‹ç»“æœï¼ˆæ— å¢å¼ºç‰ˆï¼‰**:
```
âš ï¸ 4ä¸ªå³°å­˜åœ¨ï¼Œä½†ä¸å‡åŒ€
âš ï¸ æŸäº›æ ·æœ¬å€¾å‘å•å³°
âš ï¸ ä½ç½®æœ‰åç§»ï¼ˆå¦‚45Â°ï¼‰
âš ï¸ é«˜åº¦ä¸å‡ï¼ˆæŸå³°weight>0.5ï¼‰
âš ï¸ ç¼ºä¹æ—‹è½¬ä¸å˜æ€§
```

**æ ·æœ¬åˆ†æ**:

**Sample 95** (å¢å¼ºç‰ˆ):
- GT: 4å³°ï¼Œå®Œç¾å¯¹ç§°
- Pred: 4å³°ï¼Œä¸GTé«˜åº¦é‡åˆ
- è¯„ä»·: â­â­â­â­â­ ä¼˜ç§€

**Sample 90** (æ— å¢å¼ºç‰ˆ):
- GT: 4å³°ï¼Œå‡åŒ€åˆ†å¸ƒ
- Pred: 1ä¸ªä¸»å³°ï¼ˆ45Â°æ–¹å‘ï¼‰ï¼Œå…¶ä»–å³°å¾ˆå¼±
- è¯„ä»·: â­â­ é€€åŒ–ä¸ºå•å³°

### 7.4 æ—‹è½¬ä¸å˜æ€§æµ‹è¯•

**æµ‹è¯•æ–¹æ³•**:
```python
# å¯¹åŒä¸€ç‚¹äº‘ï¼Œæ—‹è½¬ä¸åŒè§’åº¦
angles = [0Â°, 30Â°, 60Â°, 90Â°]
for angle in angles:
    pc_rotated = rotate_2d(pc, angle)
    pred_mu = model(pc_rotated)
    # é¢„æµ‹çš„Î¼åº”è¯¥ä¹Ÿæ—‹è½¬ç›¸åº”è§’åº¦
```

**å¢å¼ºç‰ˆç»“æœ**:
```
è¾“å…¥æ—‹è½¬0Â°  â†’ é¢„æµ‹ [0Â°, 90Â°, 180Â°, 270Â°]
è¾“å…¥æ—‹è½¬30Â° â†’ é¢„æµ‹ [-30Â°, 60Â°, 150Â°, 240Â°] âœ… æ­£ç¡®
è¾“å…¥æ—‹è½¬60Â° â†’ é¢„æµ‹ [-60Â°, 30Â°, 120Â°, 210Â°] âœ… æ­£ç¡®
è¾“å…¥æ—‹è½¬90Â° â†’ é¢„æµ‹ [-90Â°, 0Â°, 90Â°, 180Â°] âœ… æ­£ç¡®
```

**æ— å¢å¼ºç‰ˆç»“æœ**:
```
è¾“å…¥æ—‹è½¬0Â°  â†’ é¢„æµ‹ [0Â°, ...]
è¾“å…¥æ—‹è½¬30Â° â†’ é¢„æµ‹ [5Â°, ...] âš ï¸ åå·®å¤§
è¾“å…¥æ—‹è½¬60Â° â†’ é¢„æµ‹ [15Â°, ...] âš ï¸ åå·®å¤§
```

**ç»“è®º**: å¢å¼ºç‰ˆå…·æœ‰å¼ºæ—‹è½¬ä¸å˜æ€§

### 7.5 ä¸Baselineå¯¹æ¯”

**Baseline: 8æ–¹å‘åˆ†ç±»**
```
æ–¹æ³•: å°†360Â°åˆ†æˆ8ä¸ªbinsï¼Œåˆ†ç±»é—®é¢˜
ä¼˜ç‚¹: ç®€å•ï¼Œæ˜“è®­ç»ƒ
ç¼ºç‚¹: ç¦»æ•£ï¼Œæ— æ¦‚ç‡åˆ†å¸ƒï¼Œæ— æ³•è¡¨ç¤ºå¤šå³°
```

**å¯¹æ¯”**:

| æ–¹æ³• | è¡¨ç¤ºèƒ½åŠ› | è®­ç»ƒéš¾åº¦ | æ€§èƒ½ |
|------|---------|---------|------|
| 8æ–¹å‘åˆ†ç±» | ç¦»æ•£ï¼Œå•å³° | ç®€å• | å‡†ç¡®ç‡~85% |
| **Fixed 4å³°MvM** | **è¿ç»­ï¼Œå¤šå³°** | **ä¸­ç­‰** | **KL=0.0017** |

**MvMçš„ä¼˜åŠ¿**:
- âœ… è¾“å‡ºå®Œæ•´æ¦‚ç‡åˆ†å¸ƒï¼ˆè€Œéå•ç‚¹ï¼‰
- âœ… å¯ä»¥è¡¨ç¤ºå¤šä¸ªæ­£é¢æ–¹å‘
- âœ… è¿ç»­è§’åº¦é¢„æµ‹ï¼ˆä¸å—biné™åˆ¶ï¼‰
- âœ… ç¬¦åˆç‰©ç†ç›´è§‰ï¼ˆå¯¹ç§°ç‰©ä½“æœ‰å¤šä¸ªæ­£é¢ï¼‰

---

## 8. ä»£ç å®ç°ç»†èŠ‚

### 8.1 å…³é”®æ–‡ä»¶ç»“æ„

```
/home/pablo/ForwardNet-claude/
â”œâ”€â”€ train_pointnetpp_mvm_glassbox_augmented.py  # ä¸»è®­ç»ƒè„šæœ¬
â”œâ”€â”€ dataloader_glassbox_augmented.py            # æ•°æ®åŠ è½½å™¨
â”œâ”€â”€ models/
â”‚   â””â”€â”€ pointnet_pp_mvM.py                      # æ¨¡å‹å®šä¹‰
â””â”€â”€ results/
    â””â”€â”€ glassbox_only_20251109_183051/          # å®éªŒç»“æœ
        â”œâ”€â”€ best_model.pth                      # æœ€ä½³æ¨¡å‹
        â”œâ”€â”€ figs/
        â”‚   â”œâ”€â”€ final_predictions.png           # æœ€ç»ˆé¢„æµ‹å¯è§†åŒ–
        â”‚   â”œâ”€â”€ loss_curve.png                  # Lossæ›²çº¿
        â”‚   â””â”€â”€ predictions_epoch_*.png         # å„epoché¢„æµ‹
        â””â”€â”€ config.txt                          # é…ç½®è®°å½•
```

### 8.2 è®­ç»ƒè„šæœ¬å…³é”®ä»£ç 

**å®Œæ•´è®­ç»ƒå¾ªç¯**:
```python
#!/usr/bin/env python3
"""
è®­ç»ƒPointNet++ + MvMæ¨¡å‹åœ¨glassboxç±»åˆ«ä¸Šï¼ˆå¸¦12æ—‹è½¬å¢å¼ºï¼‰
"""
import torch
import torch.optim as optim
from pathlib import Path
from datetime import datetime

from dataloader_glassbox_augmented import GlassBoxDatasetAugmented
from models.pointnet_pp_mvM import PointNetPPMvM

# ========== é…ç½® ==========
NUM_POINTS = 10000
BATCH_SIZE = 8
EPOCHS = 50
LR = 5e-4
MAX_K = 4

# æ•°æ®å¢å¼º
ROTATION_ANGLES = list(range(0, 360, 30))  # [0, 30, ..., 330]
APPLY_JITTER = True

# è·¯å¾„
GT_ROOT = Path("data/MN40_multi_peak_vM_gt/glass_box")
PLY_ROOT = Path("data/full_mn40_normal_resampled_2d_rotated_ply/glass_box")
RESULT_DIR = Path(f"results/glassbox_{datetime.now().strftime('%Y%m%d_%H%M%S')}")
RESULT_DIR.mkdir(parents=True, exist_ok=True)

# ========== æ•°æ® ==========
# åŠ è½½æ ·æœ¬åˆ—è¡¨ï¼ˆå‡è®¾å·²é¢„å…ˆåˆ’åˆ†ï¼‰
train_samples = load_split("train")  # 217ä¸ª
val_samples = load_split("val")      # 54ä¸ª

# åˆ›å»ºDatasetï¼ˆå¸¦å¢å¼ºï¼‰
train_dataset = GlassBoxDatasetAugmented(
    samples=train_samples,
    num_points=NUM_POINTS,
    max_K=MAX_K,
    rotation_angles=ROTATION_ANGLES,
    apply_jitter=APPLY_JITTER
)  # 217 Ã— 12 = 2604ä¸ªæ ·æœ¬

val_dataset = GlassBoxDatasetAugmented(
    samples=val_samples,
    rotation_angles=ROTATION_ANGLES,
    apply_jitter=False  # éªŒè¯æ—¶ä¸åŠ æŠ–åŠ¨
)  # 54 Ã— 12 = 648ä¸ªæ ·æœ¬

# DataLoader
train_loader = DataLoader(train_dataset, batch_size=BATCH_SIZE,
                          shuffle=True, num_workers=4)
val_loader = DataLoader(val_dataset, batch_size=BATCH_SIZE,
                        shuffle=False, num_workers=4)

# ========== æ¨¡å‹ ==========
device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
model = PointNetPPMvM(max_K=MAX_K).to(device)

# ========== ä¼˜åŒ–å™¨ ==========
optimizer = optim.Adam(model.parameters(), lr=LR, weight_decay=1e-4)
scheduler = optim.lr_scheduler.StepLR(optimizer, step_size=30, gamma=0.5)

# ========== è®­ç»ƒ ==========
best_val_loss = float('inf')

for epoch in range(1, EPOCHS+1):
    # è®­ç»ƒ
    train_loss = train_one_epoch(model, train_loader, optimizer, device)

    # éªŒè¯
    val_loss = validate(model, val_loader, device)

    # å­¦ä¹ ç‡è¡°å‡
    scheduler.step()

    # ä¿å­˜æœ€ä½³æ¨¡å‹
    if val_loss < best_val_loss:
        best_val_loss = val_loss
        torch.save(model.state_dict(), RESULT_DIR / "best_model.pth")

    # å¯è§†åŒ–ï¼ˆæ¯10ä¸ªepochï¼‰
    if epoch % 10 == 0:
        visualize_predictions(model, val_loader,
                             save_path=RESULT_DIR / f"epoch_{epoch}.png")

    # æ‰“å°è¿›åº¦
    print(f"Epoch {epoch}/{EPOCHS} | "
          f"Train Loss: {train_loss:.4f} | "
          f"Val Loss: {val_loss:.4f} | "
          f"Best: {best_val_loss:.4f}")

print(f"\nè®­ç»ƒå®Œæˆï¼Best Val Loss: {best_val_loss:.4f}")
```

### 8.3 æ•°æ®åŠ è½½å™¨å…³é”®ä»£ç 

**æ—‹è½¬å¢å¼ºå®ç°**:
```python
def rotate_pointcloud_y(xyz, angle_rad):
    """ç»•Yè½´æ—‹è½¬ç‚¹äº‘ï¼ˆæ°´å¹³æ—‹è½¬ï¼‰"""
    cos_a = np.cos(angle_rad)
    sin_a = np.sin(angle_rad)

    rot_matrix = np.array([
        [cos_a,  0, sin_a],
        [0,      1, 0    ],
        [-sin_a, 0, cos_a]
    ], dtype=np.float32)

    return xyz @ rot_matrix.T

class GlassBoxDatasetAugmented(Dataset):
    def __init__(self, samples, num_points, max_K,
                 rotation_angles, apply_jitter):
        self.num_points = num_points
        self.max_K = max_K
        self.apply_jitter = apply_jitter

        # æ‰©å±•æ ·æœ¬ï¼šåŸå§‹æ ·æœ¬ Ã— æ—‹è½¬è§’åº¦
        self.augmented_samples = []
        for ply_path, gt_path, category in samples:
            for angle_deg in rotation_angles:
                self.augmented_samples.append(
                    (ply_path, gt_path, category, angle_deg)
                )

    def __getitem__(self, idx):
        ply_path, gt_path, category, angle_deg = self.augmented_samples[idx]

        # 1. è¯»å–ç‚¹äº‘
        xyz = read_ply(ply_path)  # (N, 3)

        # 2. æ—‹è½¬
        angle_rad = np.deg2rad(angle_deg)
        xyz_rotated = rotate_pointcloud_y(xyz, angle_rad)

        # 3. é‡‡æ ·
        xyz_sampled = sample_points(xyz_rotated, self.num_points)

        # 4. æŠ–åŠ¨ï¼ˆå¯é€‰ï¼‰
        if self.apply_jitter:
            xyz_sampled = add_jitter(xyz_sampled, std=0.01)

        # 5. è¯»å–GT
        K, gt_mus, gt_kappas, gt_weights = read_gt_file(gt_path)

        # 6. è°ƒæ•´GTçš„Î¼ï¼ˆæ—‹è½¬åGTä¹Ÿè¦å˜ï¼‰
        gt_mus_adjusted = (gt_mus - angle_rad) % (2 * np.pi)

        # è½¬ä¸ºtensor
        xyz_tensor = torch.from_numpy(xyz_sampled).float()
        gt_mus_tensor = torch.from_numpy(gt_mus_adjusted).float()
        gt_kappas_tensor = torch.from_numpy(gt_kappas).float()
        gt_weights_tensor = torch.from_numpy(gt_weights).float()

        return xyz_tensor, gt_mus_tensor, gt_kappas_tensor, gt_weights_tensor, K
```

### 8.4 Lossè®¡ç®—å…³é”®ä»£ç 

```python
from scipy.optimize import linear_sum_assignment

def compute_kl_loss_with_hungarian(pred_mu, pred_kappa, pred_pi,
                                     gt_mu, gt_kappa, gt_pi):
    """
    è®¡ç®—KLæ•£åº¦lossï¼ˆå¸¦HungarianåŒ¹é…ï¼‰

    Args:
        pred_mu: (batch, K) é¢„æµ‹çš„å‡å€¼è§’åº¦
        pred_kappa: (batch, K) é¢„æµ‹çš„é›†ä¸­åº¦
        pred_pi: (batch, K) é¢„æµ‹çš„æƒé‡
        gt_*: åŒä¸Šï¼ŒGround Truth

    Returns:
        loss: æ ‡é‡
    """
    batch_size, K = pred_mu.shape
    device = pred_mu.device

    # ç¦»æ•£åŒ–è§’åº¦
    theta_samples = torch.linspace(0, 2*np.pi, 360, device=device)

    total_loss = 0
    for b in range(batch_size):
        # è®¡ç®—æˆæœ¬çŸ©é˜µï¼ˆæ¯ä¸ªGTå³°ä¸æ¯ä¸ªPredå³°çš„KLæ•£åº¦ï¼‰
        cost_matrix = torch.zeros(K, K, device=device)

        for i in range(K):
            for j in range(K):
                # è®¡ç®—å•å³°ä¹‹é—´çš„KLæ•£åº¦
                gt_dist = von_mises_pdf(
                    theta_samples,
                    gt_mu[b, i],
                    gt_kappa[b, i]
                ) * gt_pi[b, i]

                pred_dist = von_mises_pdf(
                    theta_samples,
                    pred_mu[b, j],
                    pred_kappa[b, j]
                ) * pred_pi[b, j]

                # KLæ•£åº¦
                kl = (gt_dist * torch.log(
                    (gt_dist + 1e-8) / (pred_dist + 1e-8)
                )).sum()

                cost_matrix[i, j] = kl

        # Hungarianç®—æ³•æ‰¾æœ€ä¼˜åŒ¹é…
        row_ind, col_ind = linear_sum_assignment(
            cost_matrix.detach().cpu().numpy()
        )

        # ç´¯åŠ åŒ¹é…åçš„loss
        for i, j in zip(row_ind, col_ind):
            total_loss += cost_matrix[i, j]

    return total_loss / batch_size

def von_mises_pdf(theta, mu, kappa):
    """
    von Misesåˆ†å¸ƒçš„PDF

    Args:
        theta: (N,) è§’åº¦é‡‡æ ·ç‚¹
        mu: æ ‡é‡ï¼Œå‡å€¼è§’åº¦
        kappa: æ ‡é‡ï¼Œé›†ä¸­åº¦

    Returns:
        pdf: (N,) æ¦‚ç‡å¯†åº¦
    """
    from torch.special import i0  # ä¿®æ­£è´å¡å°”å‡½æ•°Iâ‚€

    normalizer = 2 * np.pi * i0(kappa)
    pdf = torch.exp(kappa * torch.cos(theta - mu)) / normalizer
    return pdf
```

### 8.5 å¯è§†åŒ–å…³é”®ä»£ç 

```python
import matplotlib.pyplot as plt

def visualize_predictions(model, data_loader, save_path, num_samples=4):
    """
    å¯è§†åŒ–æ¨¡å‹é¢„æµ‹çš„MvMåˆ†å¸ƒï¼ˆæåæ ‡å›¾ï¼‰
    """
    model.eval()

    fig, axes = plt.subplots(2, 2, figsize=(12, 12),
                             subplot_kw=dict(projection='polar'))
    axes = axes.flatten()

    with torch.no_grad():
        for idx, (xyz, gt_mu, gt_kappa, gt_pi, K) in enumerate(data_loader):
            if idx >= num_samples:
                break

            # é¢„æµ‹
            xyz = xyz.to(device)
            pred_mu, pred_kappa, pred_pi = model(xyz)

            # å–ç¬¬ä¸€ä¸ªæ ·æœ¬
            pred_mu = pred_mu[0].cpu().numpy()
            pred_kappa = pred_kappa[0].cpu().numpy()
            pred_pi = pred_pi[0].cpu().numpy()

            gt_mu = gt_mu[0].cpu().numpy()
            gt_kappa = gt_kappa[0].cpu().numpy()
            gt_pi = gt_pi[0].cpu().numpy()

            # ç»˜åˆ¶
            ax = axes[idx]

            # è®¡ç®—åˆ†å¸ƒ
            theta = np.linspace(0, 2*np.pi, 360)

            # GTåˆ†å¸ƒ
            gt_pdf = sum(
                gt_pi[i] * von_mises_pdf_numpy(theta, gt_mu[i], gt_kappa[i])
                for i in range(K)
            )

            # Predåˆ†å¸ƒ
            pred_pdf = sum(
                pred_pi[i] * von_mises_pdf_numpy(theta, pred_mu[i], pred_kappa[i])
                for i in range(K)
            )

            # ç»˜åˆ¶
            ax.plot(theta, gt_pdf, label='GT', linewidth=2)
            ax.plot(theta, pred_pdf, label='Pred', linewidth=2, linestyle='--')
            ax.legend()
            ax.set_title(f'Sample {idx+1}')

    plt.tight_layout()
    plt.savefig(save_path, dpi=150)
    plt.close()
```

---

## 9. å¦‚ä½•å¤ç°

### 9.1 ç¯å¢ƒé…ç½®

**ç³»ç»Ÿè¦æ±‚**:
```
OS: Linux (Ubuntu 20.04)
GPU: NVIDIA RTX 3090 (24GB) æˆ–åŒç­‰æ€§èƒ½
CUDA: 11.3+
Python: 3.8+
```

**Pythonä¾èµ–**:
```bash
# æ ¸å¿ƒä¾èµ–
pip install torch==1.12.0+cu113 torchvision torchaudio
pip install numpy scipy matplotlib
pip install open3d  # ç”¨äºç‚¹äº‘å¯è§†åŒ–ï¼ˆå¯é€‰ï¼‰

# PointNet++å®ç°
# ï¼ˆå‡è®¾å·²åœ¨models/ç›®å½•ä¸‹ï¼‰
```

### 9.2 æ•°æ®å‡†å¤‡

**æ­¥éª¤1ï¼šä¸‹è½½ModelNet40**
```bash
# ä¸‹è½½é“¾æ¥ï¼ˆæˆ–ä½¿ç”¨å·²æœ‰æ•°æ®ï¼‰
wget https://shapenet.cs.stanford.edu/media/modelnet40_ply_hdf5_2048.zip
unzip modelnet40_ply_hdf5_2048.zip
```

**æ­¥éª¤2ï¼šç‚¹äº‘é¢„å¤„ç†**
```bash
# è½¬æ¢ä¸ºPLYæ ¼å¼ + é‡é‡‡æ ·10000ç‚¹
python data_process/convert_and_resample.py \
    --input modelnet40_ply_hdf5_2048 \
    --output data/full_mn40_normal_resampled_2d_rotated_ply \
    --num_points 10000
```

**æ­¥éª¤3ï¼šç”ŸæˆGT**
```bash
# ä¸ºglassboxç”ŸæˆMvM GT
python data_process/2d_multi_peak_MvM_gt_1.py \
    --category glass_box \
    --output data/MN40_multi_peak_vM_gt/glass_box
```

### 9.3 è®­ç»ƒ

**åŸºç¡€è®­ç»ƒ**:
```bash
cd /path/to/ForwardNet-claude

# è®­ç»ƒï¼ˆå¢å¼ºç‰ˆï¼‰
python train_pointnetpp_mvm_glassbox_augmented.py \
    --epochs 50 \
    --batch_size 8 \
    --lr 5e-4 \
    --num_rotations 12

# è¾“å‡ºä¼šä¿å­˜åœ¨ results/glassbox_only_YYYYMMDD_HHMMSS/
```

**æ¶ˆèå®éªŒï¼ˆæ— å¢å¼ºï¼‰**:
```bash
# è®­ç»ƒï¼ˆæ— å¢å¼ºç‰ˆï¼‰
python train_pointnetpp_mvm_glassbox_no_augment.py \
    --epochs 50 \
    --batch_size 8 \
    --lr 5e-4

# å¯¹æ¯”ä¸¤ä¸ªå®éªŒçš„ç»“æœ
```

**è®­ç»ƒæ—¥å¿—**:
```bash
# å®æ—¶æŸ¥çœ‹è®­ç»ƒè¿›åº¦
python train_pointnetpp_mvm_glassbox_augmented.py 2>&1 | tee training.log

# è®­ç»ƒæ—¶é—´: ~50åˆ†é’Ÿï¼ˆRTX 3090ï¼‰
```

### 9.4 è¯„ä¼°

**æµ‹è¯•é›†è¯„ä¼°**:
```bash
# åœ¨æµ‹è¯•é›†ä¸Šè¯„ä¼°
python eval_glassbox.py \
    --model_path results/glassbox_only_20251109_183051/best_model.pth \
    --data_path data/MN40_multi_peak_vM_gt/glass_box

# è¾“å‡º: Test Loss, å¯è§†åŒ–ç­‰
```

**å¯è§†åŒ–é¢„æµ‹**:
```python
# ç”Ÿæˆé¢„æµ‹å¯è§†åŒ–
python visualize_results.py \
    --model_path results/.../best_model.pth \
    --num_samples 10 \
    --output predictions.png
```

### 9.5 å¤ç°æ£€æŸ¥æ¸…å•

**è®­ç»ƒå‰æ£€æŸ¥**:
- [ ] GPUå¯ç”¨ï¼ˆ`nvidia-smi`ï¼‰
- [ ] æ•°æ®è·¯å¾„æ­£ç¡®
- [ ] GTæ–‡ä»¶å­˜åœ¨
- [ ] ä¾èµ–å®‰è£…å®Œæ•´

**è®­ç»ƒä¸­ç›‘æ§**:
- [ ] Lossç¨³å®šä¸‹é™
- [ ] GPUåˆ©ç”¨ç‡>80%
- [ ] æ— NaN/Infé”™è¯¯
- [ ] å®šæœŸä¿å­˜checkpoint

**è®­ç»ƒåéªŒè¯**:
- [ ] Best Val Loss < 0.01
- [ ] å¯è§†åŒ–æ˜¾ç¤º4ä¸ªå³°
- [ ] Test Lossåˆç†
- [ ] ç»“æœå¯å¤ç°

---

## 10. ç»éªŒæ€»ç»“

### 10.1 æˆåŠŸçš„å…³é”®å› ç´ 

**1. é¢„è®¾è§’åº¦åˆå§‹åŒ–** â­â­â­â­â­
```
é‡è¦æ€§: æœ€å…³é”®
æ•ˆæœ: ä»å®Œå…¨å¤±è´¥(0.74) â†’ æˆåŠŸ(0.0017)
åŸå› : æ‰“ç ´å¯¹ç§°æ€§ï¼Œä½¿æ¢¯åº¦ä¸‹é™å¯è¡Œ
```

**2. æ•°æ®å¢å¼ºï¼ˆæ—‹è½¬ï¼‰** â­â­â­â­
```
é‡è¦æ€§: å¾ˆé‡è¦
æ•ˆæœ: 0.0060 â†’ 0.0017 (3.5å€æ”¹è¿›)
åŸå› : å¢åŠ æ•°æ®é‡ï¼Œæå‡æ—‹è½¬ä¸å˜æ€§
```

**3. HungarianåŒ¹é…** â­â­â­
```
é‡è¦æ€§: å¿…éœ€
åŸå› : è§£å†³æ’åˆ—ä¸å˜æ€§é—®é¢˜
```

**4. 2Då‘é‡è¡¨ç¤ºè§’åº¦** â­â­â­
```
é‡è¦æ€§: å¿…éœ€
åŸå› : å¤„ç†è§’åº¦å‘¨æœŸæ€§
```

**5. åˆç†çš„Losså‡½æ•°ï¼ˆKLæ•£åº¦ï¼‰** â­â­â­
```
é‡è¦æ€§: å¿…éœ€
åŸå› : åº¦é‡æ¦‚ç‡åˆ†å¸ƒå·®å¼‚
```

### 10.2 å¤±è´¥çš„å°è¯•

**å¤±è´¥1: Zerosåˆå§‹åŒ–**
```
åŸå› : å¯¹ç§°æ€§é™·é˜±
æ•™è®­: å¤šå³°é¢„æµ‹å¿…é¡»æ‰“ç ´å¯¹ç§°æ€§
```

**å¤±è´¥2: ç›´æ¥å›å½’è§’åº¦å€¼**
```
åŸå› : å‘¨æœŸæ€§é—®é¢˜ï¼ˆ0Â° = 360Â°ï¼‰
æ•™è®­: ç”¨å•ä½å‘é‡è¡¨ç¤ºå‘¨æœŸæ€§å˜é‡
```

**å¤±è´¥3: ä¸ç”¨HungarianåŒ¹é…**
```
åŸå› : å³°çš„é¡ºåºä¸åŒ¹é…
æ•™è®­: æ’åˆ—ä¸å˜æ€§éœ€è¦ç‰¹æ®Šå¤„ç†
```

### 10.3 è®¾è®¡åŸåˆ™

**åŸåˆ™1: åˆ©ç”¨é¢†åŸŸçŸ¥è¯†**
```
ä¾‹å­: é¢„è®¾åˆå§‹åŒ–åˆ©ç”¨äº†"glassboxæ˜¯4å‘å¯¹ç§°"çš„å…ˆéªŒ
å¯ç¤º: æ·±åº¦å­¦ä¹ ä¸æ˜¯é»‘ç›’ï¼Œé¢†åŸŸçŸ¥è¯†å¾ˆé‡è¦
```

**åŸåˆ™2: ä»ç®€å•åˆ°å¤æ‚**
```
ä¾‹å­: Fixed K=4 â†’ åç»­å¯æ‰©å±•åˆ°Variable K
å¯ç¤º: å…ˆè§£å†³ç®€å•é—®é¢˜ï¼Œå†æ³›åŒ–
```

**åŸåˆ™3: å¯è§†åŒ–é©±åŠ¨è°ƒè¯•**
```
ä¾‹å­: é€šè¿‡æåæ ‡å›¾å‘ç°4å³°é‡å é—®é¢˜
å¯ç¤º: å¯è§†åŒ–æ¯”ç›²ç›®è°ƒå‚æ›´æœ‰æ•ˆ
```

**åŸåˆ™4: æ¶ˆèå®éªŒéªŒè¯**
```
ä¾‹å­: å¯¹æ¯”æœ‰æ— æ•°æ®å¢å¼ºï¼Œé‡åŒ–å…¶è´¡çŒ®
å¯ç¤º: ç§‘å­¦å®éªŒéœ€è¦å¯¹ç…§ç»„
```

### 10.4 å¯¹åç»­å·¥ä½œçš„å¯ç¤º

**æ‰©å±•åˆ°Variable K**:
```
å½“å‰: Fixed K=4
æŒ‘æˆ˜: ä¸åŒç‰©ä½“Kä¸åŒï¼ˆK=1,2,4,8ç­‰ï¼‰
æ–¹æ¡ˆ: æ·»åŠ Ké¢„æµ‹åˆ†æ”¯ï¼ŒåŠ¨æ€åˆ†é…å³°

å…³é”®: åˆå§‹åŒ–ç­–ç•¥éœ€è¦è°ƒæ•´
  - å¯ä»¥åˆå§‹åŒ–K=8ä¸ªå³°ï¼ˆæœ€å¤§å€¼ï¼‰
  - è®©æ¨¡å‹å­¦ä¹ æƒé‡ä¸º0ï¼ˆunusedå³°ï¼‰
```

**æ‰©å±•åˆ°å…¶ä»–å¯¹ç§°ç‰©ä½“**:
```
2å‘å¯¹ç§°ï¼ˆå¦‚chairï¼‰: K=2, åˆå§‹åŒ–[0Â°, 180Â°]
6å‘å¯¹ç§°: K=6, åˆå§‹åŒ–[0Â°, 60Â°, ..., 300Â°]
8å‘å¯¹ç§°: K=8, åˆå§‹åŒ–[0Â°, 45Â°, ..., 315Â°]

å…³é”®: é¢„è®¾åˆå§‹åŒ–çš„æ¨¡å¼å¯ä»¥æ¨å¹¿
```

**å¤šç±»åˆ«æ··åˆè®­ç»ƒ**:
```
æŒ‘æˆ˜: ä¸åŒç±»åˆ«çš„"æ­£é¢"è¯­ä¹‰å¯èƒ½ä¸ä¸€è‡´
æ–¹æ¡ˆ: å…ˆç­›é€‰GTæ ‡æ³¨ä¸€è‡´çš„ç±»åˆ«
é£é™©: æ ‡æ³¨å™ªå£°ä¼šå½±å“è®­ç»ƒ

å‚è€ƒ: docs/analysis/analysis_20251109_4å‘å¯¹ç§°ç‰©ä½“æ•°æ®é›†åˆå¹¶å¯è¡Œæ€§åˆ†æ.md
```

### 10.5 å±€é™æ€§ä¸æœªæ¥æ–¹å‘

**å½“å‰å±€é™**:
1. ä»…åœ¨glassboxå•ä¸€ç±»åˆ«ä¸ŠéªŒè¯
2. Kå›ºå®šä¸º4ï¼Œä¸å¤Ÿé€šç”¨
3. ä¾èµ–æ‰‹åŠ¨æ ‡æ³¨GT
4. ä»…è€ƒè™‘æ°´å¹³æ—‹è½¬ï¼ˆ2Dï¼‰

**æœªæ¥æ–¹å‘**:
1. **Variable K**: è‡ªåŠ¨é¢„æµ‹å³°æ•°é‡
2. **å¤šç±»åˆ«æ³›åŒ–**: éªŒè¯æ–¹æ³•æ™®é€‚æ€§
3. **è‡ªç›‘ç£å­¦ä¹ **: å‡å°‘æ ‡æ³¨ä¾èµ–
4. **3Dæ—‹è½¬**: æ‰©å±•åˆ°å®Œæ•´SO(3)
5. **å®æ—¶æ¨ç†**: ä¼˜åŒ–æ¨¡å‹é€Ÿåº¦

### 10.6 è®ºæ–‡å†™ä½œå»ºè®®

**å¯å†™å…¥çš„ç« èŠ‚**:

1. **æ–¹æ³•ï¼ˆMethodï¼‰**:
   - MvMè¡¨ç¤ºçš„åŠ¨æœº
   - æ¨¡å‹æ¶æ„
   - é¢„è®¾åˆå§‹åŒ–ç­–ç•¥
   - HungarianåŒ¹é…ç®—æ³•

2. **å®éªŒï¼ˆExperimentsï¼‰**:
   - Fixed 4å³°åœ¨glassboxä¸Šçš„ç»“æœ
   - æ¶ˆèå®éªŒï¼ˆåˆå§‹åŒ–ã€æ•°æ®å¢å¼ºï¼‰
   - ä¸baselineå¯¹æ¯”
   - å¯è§†åŒ–åˆ†æ

3. **è®¨è®ºï¼ˆDiscussionï¼‰**:
   - ä¸ºä»€ä¹ˆé¢„è®¾åˆå§‹åŒ–å¦‚æ­¤æœ‰æ•ˆ
   - æ•°æ®é‡ vs åˆå§‹åŒ–è´¨é‡
   - å¯¹ç§°æ€§å­¦ä¹ çš„æŒ‘æˆ˜
   - æ–¹æ³•çš„æ³›åŒ–æ€§

**æ ¸å¿ƒè´¡çŒ®**:
1. æå‡ºç”¨MvMè¡¨ç¤ºå¤šå³°æ­£é¢æ–¹å‘
2. å‘ç°å¹¶è§£å†³å¯¹ç§°æ€§é™·é˜±é—®é¢˜
3. è¯æ˜é¢„è®¾åˆå§‹åŒ–æ¯”å¤§é‡æ•°æ®æ›´é‡è¦
4. åœ¨glassboxä¸Šè¾¾åˆ°SOTAç»“æœï¼ˆVal Loss 0.0017ï¼‰

---

## é™„å½•

### A. æ•°å­¦å…¬å¼æ±‡æ€»

**von Misesåˆ†å¸ƒ**:
```
p(Î¸ | Î¼, Îº) = exp(ÎºÂ·cos(Î¸-Î¼)) / (2Ï€Â·Iâ‚€(Îº))

å…¶ä¸­:
- Î¸: è§’åº¦ âˆˆ [0, 2Ï€]
- Î¼: å‡å€¼è§’åº¦
- Îº: é›†ä¸­åº¦ï¼ˆÎº>0ï¼‰
- Iâ‚€(Îº): ç¬¬ä¸€ç±»ä¿®æ­£è´å¡å°”å‡½æ•°
```

**æ··åˆvon Mises (MvM)**:
```
p(Î¸) = Î£áµ¢â‚Œâ‚á´· Ï€áµ¢ Â· p(Î¸ | Î¼áµ¢, Îºáµ¢)

çº¦æŸ:
- Î£Ï€áµ¢ = 1
- Ï€áµ¢ â‰¥ 0
- Îºáµ¢ > 0
```

**KLæ•£åº¦**:
```
KL(P || Q) = âˆ«â‚€Â²áµ– P(Î¸) log(P(Î¸)/Q(Î¸)) dÎ¸

ç¦»æ•£åŒ–:
KL â‰ˆ Î£â‚™ P(Î¸â‚™) log(P(Î¸â‚™)/Q(Î¸â‚™)) Â· Î”Î¸
```

### B. è¶…å‚æ•°è°ƒä¼˜è®°å½•

| è¶…å‚æ•° | å°è¯•å€¼ | æœ€ç»ˆå€¼ | è¯´æ˜ |
|--------|--------|--------|------|
| LR | 1e-3, 5e-4, 1e-4 | 5e-4 | å¹³è¡¡é€Ÿåº¦å’Œç¨³å®šæ€§ |
| Batch Size | 4, 8, 16 | 8 | å—GPUå†…å­˜é™åˆ¶ |
| Îºåˆå§‹åŒ– | 0, 1, 10 | 0 | è®©æ¨¡å‹å­¦ä¹  |
| æ—‹è½¬æ•° | 6, 12, 24 | 12 | 12å·²è¶³å¤Ÿ |

### C. ç›¸å…³è®ºæ–‡

1. **PointNet++**: Qi et al., "PointNet++: Deep Hierarchical Feature Learning on Point Sets in a Metric Space", NeurIPS 2017
2. **von Misesåˆ†å¸ƒ**: Fisher, N.I., "Statistical Analysis of Circular Data", 1993
3. **Hungarianç®—æ³•**: Kuhn, H.W., "The Hungarian method for the assignment problem", 1955

### D. ä»£ç ä»“åº“

- **GitHub**: https://github.com/0xPabloxx/3d-pointcloud-orientation-estimation
- **åˆ†æ”¯**: claude
- **ç›¸å…³æ–‡æ¡£**:
  - `docs/experiments/experiment_20251109_init_fix_results.md`
  - `docs/experiments/experiment_20251109_data_augmentation_ablation_results.md`
  - `docs/analysis/analysis_20251109_glassbox_training_failure.md`

---

**æ–‡æ¡£ç‰ˆæœ¬**: 1.0
**æœ€åæ›´æ–°**: 2025-11-09
**ä½œè€…**: Pablo (ä¸œäº¬å¤§å­¦M2) & Claude
**ç”¨é€”**: æ¯•ä¸šè®ºæ–‡å®éªŒè¯´æ˜ã€è®ºæ–‡å†™ä½œå‚è€ƒã€æ–¹æ³•å¤ç°æŒ‡å—
